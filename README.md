# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"
1. Предполагаю что системный вызов относящийся к cd при выполнении команды ```strace /bin/bash -c 'cd /tmp'``` это: ```chdir("/tmp")```
2. На основе вывода команды ```strace file /dev/tty``` предполагаю что база данных file находится в файле ```/usr/share/misc/magic.mgc```.
3. На ум приходит только ```cat /dev/null > /proc/15875/fd/3``` либо ```echo " " > /proc/15875/fd/3```. Где 15875 PID процесса занимающего файл, а 3 поток который пишет в файл.
4. Основываясь на выводе ```ps aux``` зомби-процессы не занимают ресурсы
5. После запуска ```/usr/sbin/opensnoop-bpfcc``` первые секунд 20 не происходило вообще ничего.  
   Затем появилась строчка ```1      systemd            12   0 /proc/434/cgroup```  
   Затем я во втором терминале запусит чтение файла при помощи ```cat``` и появились следующие строчки:
   ```
   17002  cat                 3   0 /etc/ld.so.cache
   17002  cat                 3   0 /lib/x86_64-linux-gnu/libc.so.6
   17002  cat                 3   0 /usr/lib/locale/locale-archive
   17002  cat                 3   0 1.txt
   ```
6. ```uname -a``` использует системный вызов ```uname```. По запросу ```man 2 uname``` получаю следующее ```No manual entry for uname in section 2```, хотя в ```man uname``` в секции see also есть упоминание uname(2). На странице https://manpages.org/uname/2 можно найти следующую цитату с описанием альтернативного местоположения в /proc, где можно узнать версию ядра и релиз ОС:
   ```
   Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
   ```
7. * ; - просто разделяет команды между собой в последовательности команд.  
   * && - вторая команда будет выполнена только в случае успешного выполнения первой.  
  Если применить в bash-скрипте ```set -e```, то использование ```&&``` - не имеет смысла т.к. ```set -e``` останавливает выполнение скрипта при любом ненулевом коде завершения команды.
8. Режим bash ```set -euxo pipefail``` состоит из следующих опций:
   * -e: Немедленный выход в случае ненулевого кода завершения любой команды
   * -u: Рассматривает неустановленные переменные и параметры, отличные от специальных параметров "@" и "*", как ошибку при выполнении расширения параметров. Если предпринята попытка расширения для неустановленной переменной или параметра, оболочка выводит сообщение об ошибке и, если оно не интерактивно, завершает работу с ненулевым статусом.
   * -x: включает режим при котором все выполняемые команды выводятся в терминал.
   * -o: позволяет использовать дополнительные опции, которой какраз и является pipefail. pipefail - завершает выполнение скрипта если какая-либо из команд в конвеере завершилась с ненулевым кодом завершения.  

   Данная связка по сути добавляет логирование и завершает выполнение скрипта если какаято из команд в скипте завершилась с ненулевым кодом завершения что хорошо т.к. если какаято из команд выдала ошибку, а последующие будут работать с неправильным выводом или вообще без него - то это может привести к непредвиденным последствиям выполнения скрипта.
9. Наиболее часто встречающийся в моей системе статус процесса это: ```S - interruptible sleep (waiting for an event to complete)```